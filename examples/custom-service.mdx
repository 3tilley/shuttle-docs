---
title: "Custom Service"
description: "This example will explain how to create a custom shuttle service using Poise and Axum."
---

In this simple example we will implement `Service` for a custom service that serves a Discord bot alongside a web server created using Axum.

### Prerequisites

To be able to create this example, we'll need to grab an API token from the [Discord developer portal](https://discord.com/developers/applications).

1. Click the New Application button, name your application and click Create.
2. Navigate to the Bot tab in the lefthand menu, and add a new bot.
3. On the bot page click the Reset Token button to reveal your token. Put this token in your `Secrets.toml`. It's very important that you don't reveal your token to anyone, as it can be abused. Create a `.gitignore` file to omit your `Secrets.toml` from version control.

To add the bot to a server, we need to create an invite link:

1. On your bot's application page, open the OAuth2 page via the lefthand panel.
2. Go to the URL Generator via the lefthand panel, and select the `bot` scope as well as the `Send Messages` permission in the Bot Permissions section.
3. Copy the URL, open it in your browser and select a Discord server you wish to invite the bot to.


### Initial Setup
Start by running the following command:
```bash
cargo shuttle init --no-framework
```

This will simply initialize a new cargo crate with a dependency on `shuttle-service`.
We also want to add several dependencies for this - make sure your Cargo.toml looks like below:

```toml Cargo.toml
[package]
name = "custom-service"
version = "0.1.0"
edition = "2021"

[lib]

[dependencies]
anyhow = "1.0.62"
axum = "0.6.4"
hyper = "0.14.24"
poise = "0.5.2"
serde = "1.0"
shuttle-secrets = "0.9.0"
shuttle-service = { version = "0.9.0", features = ["bot-serenity"] }
tokio = "1.22.0"
```

### Getting Started
To get started, we need to return a wrapper struct from our `shuttle_service::main` function that 
implements `shuttle_service::Service`, which we can declare like so:

```rust
struct CustomService {
    discord_token: String,
}
```

Then we need to implement `shuttle_service::Service` for our wrapper. If you need to bind to an address,
for example if you're implementing service for an HTTP server, you can use the `addr` argument from `bind`.
You can only have one HTTP service bound to the `addr`, but you can start other services that don't rely on 
binding to a socket.

We can do do this by simply creating an Arc value from `self` and then cloning it every time we want to use it,
and spawning another thread to run the service like so:

```rust lib.rs
#[shuttle_service::async_trait]
impl shuttle_service::Service for CustomService {
    async fn bind(
        mut self: Box<Self>,
        _addr: std::net::SocketAddr,
    ) -> Result<(), shuttle_service::error::Error> {
        let service = Arc::new(self);

        let router = Arc::clone(&service);

        tokio::spawn(async move {
            Arc::clone(&service)
                .set_up_bot()
                .await
                .expect("Something went wrong with the bot! :(");
        });

        router
            .set_up_router(addr)
            .await
            .expect("Something went wrong with the router! :(");

        Ok(())
    }
}
```
### Commands/Routing
Before we can actually run the program, we will need to set up the commands and routing that it needs
 before we can add them to the struct implementation. Let's do that now:

```rust commands.rs
use crate::Data;
use poise::serenity_prelude as serenity;

type Error = Box<dyn std::error::Error + Send + Sync>;
type Context<'a> = poise::Context<'a, Data, Error>;

#[poise::command(slash_command, prefix_command)]
pub async fn age(
    ctx: Context<'_>,
    #[description = "Selected user"] user: Option<serenity::User>,
) -> Result<(), Error> {
    let u = user.as_ref().unwrap_or_else(|| ctx.author());
    let response = format!("{}'s account was created at {}", u.name, u.created_at());
    ctx.say(response).await?;
    Ok(())
}
```

```rust router.rs
use axum::http::StatusCode;
use axum::response::IntoResponse;
use axum::{routing::get, Router};

pub fn router() -> Router {
    Router::new().route("/", get(hello_world))
}

pub async fn hello_world() -> impl IntoResponse {
    (StatusCode::OK, "Hello world!").into_response()
}
```

### Struct Implementation
To finish up, we return the wrapper struct from our `shuttle_service::main` function and add implementation
for setting up each of our services for the struct, like so:

```rust lib.rs
use poise::serenity_prelude as serenity;
use shuttle_secrets::SecretStore;
use std::sync::Arc;

mod commands;
use commands::age;

mod router;
use router::router;

pub struct Data {}
pub struct CustomService {
    discord_api_key: String,
}

#[shuttle_service::main]
async fn init(
    #[shuttle_shared_db::Postgres] pool: sqlx::PgPool,
) -> Result<PoolService, shuttle_service::Error> {
    Ok(PoolService { pool })
}

impl CustomService {
    async fn set_up_bot(&self) -> Result<(), Box<dyn std::error::Error>> {
        let framework = poise::Framework::builder()
            .options(poise::FrameworkOptions {
                commands: vec![age()],
                ..Default::default()
            })
            .token(&self.discord_api_key)
            .intents(serenity::GatewayIntents::non_privileged())
            .setup(|ctx, _ready, framework| {
                Box::pin(async move {
                    poise::builtins::register_globally(ctx, &framework.options().commands).await?;
                    Ok(Data {})
                })
            });

        framework.run().await.unwrap();

        Ok(())
    }

    async fn set_up_router(&self, addr: std::net::SocketAddr) -> Result<(), hyper::Error> {
        let router = router();

        let router = axum::Server::bind(&addr).serve(router.into_make_service());

        router.await
    }
}
```
### Finishing Up
Try it out with the `run` command:

```bash
cargo shuttle run
```
